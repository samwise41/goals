    <script>
        // ---------------------------------------------------------
        // CONFIGURATION
        // ---------------------------------------------------------
        const REPO_OWNER = 'samwise41';
        const REPO_NAME = 'goals';
        const FILE_PATH = 'familygoals.md';

        // ---------------------------------------------------------
        // 1. AUTHENTICATION & STARTUP
        // ---------------------------------------------------------
        document.addEventListener("DOMContentLoaded", checkAuth);

        function checkAuth() {
            const token = localStorage.getItem('github_pat');
            if (token) {
                document.getElementById('login-modal').style.display = 'none';
                loadGoals(token);
            }
        }

        async function attemptLogin() {
            const input = document.getElementById('token-input');
            const msg = document.getElementById('login-msg');
            const btn = document.getElementById('login-btn');
            const token = input.value.trim();

            if (!token) return;

            btn.disabled = true;
            btn.textContent = "Verifying...";
            msg.style.display = 'none';

            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: { 'Authorization': `token ${token}` }
                });

                if (response.ok) {
                    localStorage.setItem('github_pat', token);
                    document.getElementById('login-modal').style.display = 'none';
                    loadGoals(token);
                } else {
                    throw new Error("Invalid Token");
                }
            } catch (err) {
                msg.textContent = "Invalid Token. Please try again.";
                msg.style.display = 'block';
                btn.disabled = false;
                btn.textContent = "Unlock";
            }
        }

        // ---------------------------------------------------------
        // 2. FETCH AND PARSE MARKDOWN
        // ---------------------------------------------------------
        async function loadGoals(token) {
            try {
                const response = await fetch(FILE_PATH + '?t=' + new Date().getTime());
                if (!response.ok) throw new Error("Could not find " + FILE_PATH);
                const text = await response.text();
                parseMarkdown(text);
            } catch (error) {
                document.getElementById('loading').innerHTML = 
                    `Error loading goals. <br>Ensure '${FILE_PATH}' is in the same folder.`;
                console.error(error);
            }
        }

        function parseMarkdown(markdown) {
            const lines = markdown.split('\n');
            const people = {};
            let currentPerson = null;
            let currentCategory = null;

            lines.forEach((line, index) => {
                const rawLine = line;
                
                if (rawLine.trim().startsWith('## ')) {
                    currentPerson = rawLine.replace('## ', '').trim();
                    people[currentPerson] = { Social: [], Spiritual: [], Physical: [], Intellectual: [] };
                    currentCategory = null; 
                }
                else if (rawLine.trim().startsWith('### ')) {
                    currentCategory = rawLine.replace('### ', '').trim();
                }
                else {
                    // UPDATED REGEX: Makes the leading checkbox optional
                    // Group 1: Indent, Group 2: Checkbox State (optional), Group 3: Text
                    const taskMatch = rawLine.match(/^(\s*)(?:-|\*)\s*(?:\[([ xX])\])?\s*(.*)/);

                    if (taskMatch) {
                        const indentation = taskMatch[1].length; 
                        
                        // Check if a leading checkbox exists
                        const hasLeadingCheckbox = taskMatch[2] !== undefined;
                        const isChecked = hasLeadingCheckbox && taskMatch[2].toLowerCase() === 'x';
                        
                        let goalText = taskMatch[3];
                        goalText = goalText.replace(/\[cite.*?\]/gi, '')
                                           .replace(/\[source.*?\]/gi, '')
                                           .trim();

                        const isSubTask = indentation >= 2;
                        
                        const goalObj = { 
                            text: goalText, 
                            hasCheckbox: hasLeadingCheckbox, // Store this for the renderer
                            checked: isChecked, 
                            lineIndex: index,
                            subTasks: [] 
                        };

                        if (isSubTask) {
                            if (currentPerson && currentCategory && people[currentPerson][currentCategory].length > 0) {
                                const goalsList = people[currentPerson][currentCategory];
                                goalsList[goalsList.length - 1].subTasks.push(goalObj);
                            }
                        } else {
                            if (currentPerson && currentCategory && people[currentPerson][currentCategory]) {
                                people[currentPerson][currentCategory].push(goalObj);
                            }
                        }
                    }
                }
            });

            renderGoals(people);
        }

        // ---------------------------------------------------------
        // 3. RENDER HTML (UPDATED FOR OPTIONAL MAIN CHECKBOX)
        // ---------------------------------------------------------
        function renderGoals(people) {
            const navContainer = document.getElementById('dynamic-nav-container');
            const mainContainer = document.getElementById('main-content');
            const loadingDiv = document.getElementById('loading');
            
            navContainer.innerHTML = '';
            const oldTabs = document.querySelectorAll('.tab-content:not(#home)');
            oldTabs.forEach(tab => tab.remove());
            loadingDiv.style.display = 'none';

            // Helper to render inline boxes
            // startIndex tells it whether to start counting at 0 or 1
            function processTextWithCheckboxes(text, lineIndex, startIndex) {
                let matchCount = startIndex;
                return text.replace(/\[([ xX])\]/g, (match, state) => {
                    const currentIndex = matchCount; 
                    matchCount++;
                    const checked = state.toLowerCase() === 'x' ? 'checked' : '';
                    return `<input type="checkbox" class="tracker-check" ${checked} onchange="toggleGoal(this, ${lineIndex}, ${currentIndex})">`;
                });
            }

            // Helper to render a single List Item (Goal or Subtask)
            function renderItem(goal, isSub) {
                // If the line has a main checkbox (e.g. "- [ ] Text"), matchIndex for inline items starts at 1
                // If NO main checkbox (e.g. "- Text"), matchIndex for inline items starts at 0
                const startIndex = goal.hasCheckbox ? 1 : 0;
                
                let prefixHtml = '';
                if (goal.hasCheckbox) {
                    const checked = goal.checked ? 'checked' : '';
                    prefixHtml = `<input type="checkbox" ${checked} onchange="toggleGoal(this, ${goal.lineIndex}, 0)">`;
                } else {
                    // Render a bullet if there is no checkbox, to keep it looking like a list
                    prefixHtml = `<span style="margin-right: 12px; font-weight: bold; color: var(--accent-color);">&bull;</span>`;
                }

                const processedText = processTextWithCheckboxes(goal.text, goal.lineIndex, startIndex);
                
                return `<li class="${isSub ? 'sub-task' : ''}">
                    ${prefixHtml} 
                    <span class="goal-text-container">${processedText}</span>
                </li>`;
            }

            for (const personName in people) {
                const safeId = personName.toLowerCase().replace(/\s+/g, '-');
                const link = document.createElement('a');
                link.href = '#' + safeId;
                link.className = 'nav-btn';
                link.id = 'btn-' + safeId;
                link.textContent = personName;
                navContainer.appendChild(link);

                const contentDiv = document.createElement('div');
                contentDiv.id = safeId;
                contentDiv.className = 'tab-content';
                
                let html = `<h1>${personName}'s Goals</h1><div class="goals-grid">`;
                const categories = ['Social', 'Spiritual', 'Physical', 'Intellectual'];
                
                categories.forEach(cat => {
                    let icon = '';
                    if(cat === 'Social') icon = 'üë•';
                    if(cat === 'Spiritual') icon = 'üïäÔ∏è';
                    if(cat === 'Physical') icon = 'üí™';
                    if(cat === 'Intellectual') icon = 'üß†';

                    html += `<div class="quadrant ${cat}"><h3>${icon} ${cat}</h3><ul>`;
                    
                    const goals = people[personName][cat] || [];
                    if (goals.length === 0) {
                        html += `<li>No goals listed</li>`;
                    } else {
                        goals.forEach(goal => {
                            html += renderItem(goal, false);
                            if (goal.subTasks.length > 0) {
                                goal.subTasks.forEach(sub => {
                                    html += renderItem(sub, true);
                                });
                            }
                        });
                    }
                    html += `</ul></div>`;
                });

                html += `</div>`;
                contentDiv.innerHTML = html;
                mainContainer.appendChild(contentDiv);
            }
            handleRouting();
        }

        // ---------------------------------------------------------
        // 4. GITHUB UPDATE LOGIC
        // ---------------------------------------------------------
        async function toggleGoal(checkbox, lineIndex, matchIndex) {
            let token = localStorage.getItem('github_pat');
            if (!token) {
                alert("Session expired. Please refresh to login.");
                location.reload();
                return;
            }

            checkbox.disabled = true;
            document.body.style.cursor = 'wait';

            try {
                const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${FILE_PATH}`;
                
                const getResponse = await fetch(apiUrl, {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });

                if (!getResponse.ok) {
                    if (getResponse.status === 401) {
                        localStorage.removeItem('github_pat');
                        alert("Token expired. Please refresh to login.");
                        location.reload();
                        return;
                    }
                    throw new Error('Failed to fetch file info from GitHub.');
                }
                
                const data = await getResponse.json();
                const sha = data.sha;
                const content = new TextDecoder().decode(Uint8Array.from(atob(data.content), c => c.charCodeAt(0)));
                const lines = content.split('\n');
                
                let targetLine = lines[lineIndex];
                let occurrence = 0;
                const regex = /\[([ xX])\]/g;
                
                const newLine = targetLine.replace(regex, (match) => {
                    if (occurrence === matchIndex) {
                        occurrence++;
                        if (match.includes('[ ]')) return '[x]';
                        return '[ ]';
                    }
                    occurrence++;
                    return match;
                });

                lines[lineIndex] = newLine;
                const newContent = lines.join('\n');
                const newContentBase64 = btoa(String.fromCharCode(...new TextEncoder().encode(newContent)));

                const putResponse = await fetch(apiUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: `Update goal status (index ${matchIndex})`,
                        content: newContentBase64,
                        sha: sha
                    })
                });

                if (!putResponse.ok) throw new Error('Failed to update GitHub file.');
                console.log("Goal updated successfully on GitHub!");

            } catch (error) {
                console.error(error);
                alert("Error: " + error.message);
                checkbox.checked = !checkbox.checked; 
            } finally {
                checkbox.disabled = false;
                document.body.style.cursor = 'default';
            }
        }

        // ---------------------------------------------------------
        // 5. TAB LOGIC & ROUTING
        // ---------------------------------------------------------
        function switchTab(personId) {
            const contents = document.getElementsByClassName("tab-content");
            for (let i = 0; i < contents.length; i++) {
                contents[i].style.display = "none";
                contents[i].classList.remove("active");
            }
            const buttons = document.getElementsByClassName("nav-btn");
            for (let i = 0; i < buttons.length; i++) {
                buttons[i].classList.remove("active");
            }

            const target = document.getElementById(personId);
            if (target) {
                target.style.display = "block";
                setTimeout(() => target.classList.add("active"), 10);
            }
            
            const btn = document.getElementById("btn-" + personId);
            if (btn) btn.classList.add("active");

            if (window.innerWidth <= 768) closeMenu();
        }

        function handleRouting() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                switchTab(hash);
            } else {
                history.replaceState(null, null, '#home');
                switchTab('home');
            }
        }

        window.addEventListener('hashchange', function() {
            switchTab(window.location.hash.substring(1));
        });

        function toggleMenu() {
            document.getElementById("sidebar").classList.toggle("open");
            document.querySelector(".overlay").classList.toggle("active");
        }
        function closeMenu() {
            document.getElementById("sidebar").classList.remove("open");
            document.querySelector(".overlay").classList.remove("active");
        }
    </script>
